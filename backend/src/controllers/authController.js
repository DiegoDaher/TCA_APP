import jwt from 'jsonwebtoken';
import User from '../models/userModel.js';
import sequelize from '../config/db.js';
import { generateRandomPassword } from '../utils/generatePassword.js';
import nodemailer from 'nodemailer';

const JWT_SECRET = process.env.JWT_SECRET || 'tu_clave_secreta_super_segura_cambiala_en_produccion';
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';

// Generar token JWT
const generateToken = (userId) => {
  return jwt.sign({ id: userId }, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });
};

// Registro de usuario
export const register = async (req, res) => {
  try {
    const { Nombres, Apellidos, Correo_Electronico, Contrase√±a, rol_id } = req.body;

    // Validaciones
    if (!Correo_Electronico) {
      return res.status(400).json({ 
        error: 'El campo Correo_Electronico es obligatorio.' 
      });
    }

    // Si no se proporciona contrase√±a, generar una aleatoria
    let passwordToUse = Contrase√±a;
    let isAutoGeneratedPassword = false;
    
    if (!Contrase√±a) {
      passwordToUse = generateRandomPassword(12);
      isAutoGeneratedPassword = true;
    } else if (Contrase√±a.length < 6) {
      return res.status(400).json({ 
        error: 'La contrase√±a debe tener al menos 6 caracteres.' 
      });
    }

    // Verificar si el usuario ya existe
    const existingUser = await User.findOne({ 
      where: { Correo_Electronico } 
    });

    if (existingUser) {
      return res.status(400).json({ 
        error: 'El correo electr√≥nico ya est√° registrado.' 
      });
    }

    // Crear el usuario
    const newUser = await User.create({
      Nombres: Nombres || null,
      Apellidos: Apellidos || null,
      Correo_Electronico,
      Contrase√±a: passwordToUse,
      Status: 1,
    });

    // Si la contrase√±a fue generada autom√°ticamente, enviar correo
    if (isAutoGeneratedPassword) {
      const userName = Nombres || Correo_Electronico.split('@')[0];
      
      // Configurar transporter de Gmail
      const transporter = nodemailer.createTransport({
        service: 'gmail',
        auth: {
          user: process.env.EMAIL_USER,
          pass: process.env.EMAIL_PASS
        }
      });

      // Configurar el email
      const mailOptions = {
        from: `"TCA - Acervo Bibliogr√°fico" <${process.env.EMAIL_USER}>`,
        to: Correo_Electronico,
        subject: 'Bienvenido - Tu cuenta ha sido creada',
        text: `Hola ${userName}, tu cuenta ha sido creada exitosamente. Tu contrase√±a temporal es: ${passwordToUse}`,
        html: `
          <!DOCTYPE html>
          <html>
          <head>
            <style>
              body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
              .container { max-width: 600px; margin: 0 auto; padding: 20px; }
              .header { background-color: #801530; color: white; padding: 20px; text-align: center; border-radius: 8px 8px 0 0; }
              .content { background-color: #f9f9f9; padding: 30px; border: 1px solid #ddd; border-radius: 0 0 8px 8px; }
              .password-box { background-color: #fff; border: 2px solid #801530; padding: 20px; margin: 20px 0; text-align: center; border-radius: 8px; }
              .password { font-size: 24px; font-weight: bold; letter-spacing: 2px; color: #801530; font-family: 'Courier New', monospace; }
              .footer { margin-top: 20px; text-align: center; font-size: 12px; color: #666; }
              .warning { background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 10px; margin: 15px 0; color: #856404; }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="header">
                <h1>¬°Bienvenido a TCA!</h1>
              </div>
              <div class="content">
                <p>Hola <strong>${userName}</strong>,</p>
                <p>Tu cuenta ha sido creada exitosamente en nuestro sistema.</p>
                <p>Tu contrase√±a temporal es:</p>
                <div class="password-box">
                  <div class="password">${passwordToUse}</div>
                </div>
                <div class="warning">
                  <strong>‚ö†Ô∏è Importante:</strong> Por seguridad, te recomendamos cambiar esta contrase√±a despu√©s de iniciar sesi√≥n por primera vez.
                </div>
                <p>Puedes iniciar sesi√≥n usando tu correo electr√≥nico y esta contrase√±a.</p>
              </div>
              <div class="footer">
                <hr>
                <p>Si no solicitaste esta cuenta, por favor ignora este correo.</p>
                <p><strong>TCA - Sistema de Acervo Bibliogr√°fico</strong></p>
                <p>üìß ${process.env.EMAIL_USER}</p>
              </div>
            </div>
          </body>
          </html>
        `
      };

      // Enviar el email
      try {
        const info = await transporter.sendMail(mailOptions);
        console.log('='.repeat(50));
        console.log('‚úÖ EMAIL DE REGISTRO ENVIADO');
        console.log('='.repeat(50));
        console.log(`Usuario: ${userName}`);
        console.log(`Email: ${Correo_Electronico}`);
        console.log(`Message ID: ${info.messageId}`);
        console.log('='.repeat(50));
      } catch (emailError) {
        console.error('‚ùå Error al enviar email de registro:', emailError);
        // No falla el registro si el email no se env√≠a
      }
    }

    // Si se proporcion√≥ un rol_id, asignarlo al usuario
    if (rol_id) {
      await sequelize.query(`
        INSERT INTO rolUsuarios (usuario_id, rol_id, asignado_por, asignado_en)
        VALUES (:usuario_id, :rol_id, NULL, NOW())
      `, {
        replacements: { 
          usuario_id: newUser.Id, 
          rol_id: rol_id 
        },
        type: sequelize.QueryTypes.INSERT,
      });
    }

    // Obtener los roles del usuario
    const roles = await sequelize.query(`
      SELECT r.id, r.nombre, r.slug, r.descripcion
      FROM roles r
      JOIN rolUsuarios ru ON r.id = ru.rol_id
      WHERE ru.usuario_id = :usuario_id
    `, {
      replacements: { usuario_id: newUser.Id },
      type: sequelize.QueryTypes.SELECT,
    });

    // Generar token
    const token = generateToken(newUser.Id);

    res.status(201).json({
      message: isAutoGeneratedPassword 
        ? 'Usuario registrado exitosamente. Se ha enviado la contrase√±a temporal por correo.' 
        : 'Usuario registrado exitosamente',
      emailSent: isAutoGeneratedPassword,
      token,
      user: {
        Id: newUser.Id,
        Nombres: newUser.Nombres,
        Apellidos: newUser.Apellidos,
        Correo_Electronico: newUser.Correo_Electronico,
        Status: newUser.Status,
        roles: roles.map(r => ({
          id: r.id,
          nombre: r.nombre,
          slug: r.slug,
          descripcion: r.descripcion
        })),
        roleSlugs: roles.map(r => r.slug),
      },
    });
  } catch (error) {
    res.status(500).json({ error: `Error al registrar usuario: ${error.message}` });
  }
};

// Login de usuario
export const login = async (req, res) => {
  try {
    const { Correo_Electronico, Contrase√±a } = req.body;

    // Validaciones
    if (!Correo_Electronico || !Contrase√±a) {
      return res.status(400).json({ 
        error: 'Correo_Electronico y Contrase√±a son obligatorios.' 
      });
    }

    // Buscar usuario por email
    const user = await User.findOne({ 
      where: { Correo_Electronico } 
    });

    if (!user) {
      return res.status(401).json({ 
        error: 'Credenciales inv√°lidas.' 
      });
    }

    if (user.Status !== 1) {
      return res.status(401).json({ 
        error: 'Usuario inactivo. Contacta al administrador.' 
      });
    }

    // Verificar contrase√±a
    const isPasswordValid = await user.comparePassword(Contrase√±a);

    if (!isPasswordValid) {
      return res.status(401).json({ 
        error: 'Credenciales inv√°lidas.' 
      });
    }

    // Obtener los roles del usuario
    const roles = await sequelize.query(`
      SELECT r.id, r.nombre, r.slug, r.descripcion
      FROM roles r
      JOIN rolUsuarios ru ON r.id = ru.rol_id
      WHERE ru.usuario_id = :usuario_id
    `, {
      replacements: { usuario_id: user.Id },
      type: sequelize.QueryTypes.SELECT,
    });

    // Generar token
    const token = generateToken(user.Id);

    res.status(200).json({
      message: 'Login exitoso',
      token,
      user: {
        Id: user.Id,
        Nombres: user.Nombres,
        Apellidos: user.Apellidos,
        Correo_Electronico: user.Correo_Electronico,
        Status: user.Status,
        roles: roles.map(r => ({
          id: r.id,
          nombre: r.nombre,
          slug: r.slug,
          descripcion: r.descripcion
        })),
        roleSlugs: roles.map(r => r.slug),
      },
    });
  } catch (error) {
    res.status(500).json({ error: `Error al iniciar sesi√≥n: ${error.message}` });
  }
};

// Obtener perfil del usuario autenticado
export const getProfile = async (req, res) => {
  try {
    const user = await User.findByPk(req.user.id, {
      attributes: { exclude: ['Contrase√±a'] },
    });

    if (!user) {
      return res.status(404).json({ error: 'Usuario no encontrado.' });
    }

    res.status(200).json({
      message: 'Perfil obtenido exitosamente',
      user: {
        ...user.toJSON(),
        roles: req.user.roles || [],
        roleSlugs: req.user.roleSlugs || [],
      },
    });
  } catch (error) {
    res.status(500).json({ error: `Error al obtener perfil: ${error.message}` });
  }
};

// Verificar token
export const verifyToken = async (req, res) => {
  try {
    res.status(200).json({
      message: 'Token v√°lido',
      user: req.user,
    });
  } catch (error) {
    res.status(500).json({ error: `Error al verificar token: ${error.message}` });
  }
};

// Obtener todos los usuarios con paginaci√≥n
export const getAllUsers = async (req, res) => {
  try {
    const { page = 1, limit = 10, column, value } = req.query;
    const offset = (page - 1) * limit;
    
    let where = {};
    
    // B√∫squeda por columna espec√≠fica
    if (column && value) {
      const { Op } = await import('sequelize');
      
      switch (column) {
        case 'Nombres':
        case 'Nombre(s)':
          where.Nombres = { [Op.like]: `${value}%` };
          break;
        case 'Apellidos':
        case 'Apellido(s)':
          where.Apellidos = { [Op.like]: `${value}%` };
          break;
        case 'Correo_Electronico':
          where.Correo_Electronico = { [Op.like]: `${value}%` };
          break;
        case 'Status':
          const statusValue = value === 'Activo' || value === '1' ? 1 : 0;
          where.Status = statusValue;
          break;
        case 'Rol':
        case 'rol':
          // B√∫squeda por rol - necesitaremos hacer un JOIN con rolUsuarios y roles
          // Por ahora, lo dejamos preparado para futura implementaci√≥n
          break;
        default:
          break;
      }
    }

    const { count, rows } = await User.findAndCountAll({
      where,
      attributes: { exclude: ['Contrase√±a'] },
      offset: parseInt(offset),
      limit: parseInt(limit),
      order: [['Id', 'ASC']],
    });

    const totalPages = Math.ceil(count / limit);

    res.status(200).json({
      message: 'Usuarios obtenidos exitosamente',
      users: rows,
      pagination: {
        currentPage: parseInt(page),
        totalPages,
        totalItems: count,
        itemsPerPage: parseInt(limit),
      },
    });
  } catch (error) {
    res.status(500).json({ error: `Error al obtener usuarios: ${error.message}` });
  }
};

// Cambiar contrase√±a
export const changePassword = async (req, res) => {
  try {
    const { Contrase√±a, Nueva_Contrase√±a, Confirmar_Contrase√±a } = req.body;

    // Validaciones
    if (!Contrase√±a || !Nueva_Contrase√±a || !Confirmar_Contrase√±a) {
      return res.status(400).json({ 
        error: 'Todos los campos son obligatorios.' 
      });
    }

    // Validar longitud de la nueva contrase√±a
    if (Nueva_Contrase√±a.length < 8) {
      return res.status(400).json({ 
        error: 'La nueva contrase√±a debe tener al menos 8 caracteres.' 
      });
    }
    const passwordPattern = /(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/;
    if (!passwordPattern.test(Nueva_Contrase√±a)) {
      return res.status(400).json({
        error: 'La nueva contrase√±a debe contener al menos una letra may√∫scula, una letra min√∫scula y un n√∫mero.'
      });
    }

    // Verificar que las contrase√±as nuevas coincidan
    if (Nueva_Contrase√±a !== Confirmar_Contrase√±a) {
      return res.status(400).json({ 
        error: 'La nueva contrase√±a y la confirmaci√≥n no coinciden.' 
      });
    }

    // Verificar que la nueva contrase√±a sea diferente de la actual
    if (Contrase√±a === Nueva_Contrase√±a) {
      return res.status(400).json({ 
        error: 'La nueva contrase√±a debe ser diferente de la actual.' 
      });
    }

    // Buscar usuario (req.user viene del middleware de autenticaci√≥n)
    const user = await User.findByPk(req.user.id);

    if (!user) {
      return res.status(404).json({ 
        error: 'Usuario no encontrado.' 
      });
    }

    // Verificar la contrase√±a actual
    const isPasswordValid = await user.comparePassword(Contrase√±a);

    if (!isPasswordValid) {
      return res.status(401).json({ 
        error: 'La contrase√±a actual es incorrecta.' 
      });
    }

    // Actualizar la contrase√±a (el hook beforeUpdate hashear√° autom√°ticamente)
    user.Contrase√±a = Nueva_Contrase√±a;
    await user.save();

    res.status(200).json({
      message: 'Contrase√±a actualizada exitosamente',
    });
  } catch (error) {
    res.status(500).json({ error: `Error al cambiar contrase√±a: ${error.message}` });
  }
};

// Desactivar usuario (cambiar Status a 0/false)
export const deactivateUser = async (req, res) => {
  try {
    const { id } = req.params;

    // Validar que el ID sea un n√∫mero entero
    if (!id || isNaN(id) || !Number.isInteger(Number(id))) {
      return res.status(400).json({ error: 'El ID debe ser un n√∫mero entero v√°lido.' });
    }

    // Buscar usuario por ID
    const user = await User.findByPk(id);

    if (!user) {
      return res.status(404).json({ 
        error: 'Usuario no encontrado.' 
      });
    }

    // Verificar si el usuario ya est√° desactivado
    if (user.Status === 0 || user.Status === false) {
      return res.status(400).json({ 
        error: 'El usuario ya est√° desactivado.' 
      });
    }

    // Cambiar Status a 0/false
    user.Status = 0;
    await user.save();

    res.status(200).json({
      message: 'Usuario desactivado exitosamente',
      user: {
        Id: user.Id,
        Nombres: user.Nombres,
        Apellidos: user.Apellidos,
        Correo_Electronico: user.Correo_Electronico,
        Status: user.Status,
      },
    });
  } catch (error) {
    res.status(500).json({ error: `Error al desactivar usuario: ${error.message}` });
  }
};

// Restaurar usuario (cambiar Status a 1/true)
export const restoreUser = async (req, res) => {
  try {
    const { id } = req.params;

    // Validar que el ID sea un n√∫mero entero
    if (!id || isNaN(id) || !Number.isInteger(Number(id))) {
      return res.status(400).json({ error: 'El ID debe ser un n√∫mero entero v√°lido.' });
    }

    // Buscar usuario por ID
    const user = await User.findByPk(id);

    if (!user) {
      return res.status(404).json({ 
        error: 'Usuario no encontrado.' 
      });
    }

    // Verificar si el usuario ya est√° activo
    if (user.Status === 1 || user.Status === true) {
      return res.status(400).json({ 
        error: 'El usuario ya est√° activo.' 
      });
    }

    // Cambiar Status a 1/true
    user.Status = 1;
    await user.save();

    res.status(200).json({
      message: 'Usuario restaurado exitosamente',
      user: {
        Id: user.Id,
        Nombres: user.Nombres,
        Apellidos: user.Apellidos,
        Correo_Electronico: user.Correo_Electronico,
        Status: user.Status,
      },
    });
  } catch (error) {
    res.status(500).json({ error: `Error al restaurar usuario: ${error.message}` });
  }
};

// Obtener usuario por ID (protegido)
export const getUserById = async (req, res) => {
  try {
    const { id } = req.params;

    // Validar que el ID sea un n√∫mero entero
    if (!id || isNaN(id) || !Number.isInteger(Number(id))) {
      return res.status(400).json({ error: 'El ID debe ser un n√∫mero entero v√°lido.' });
    }

    // Buscar usuario por ID excluyendo la contrase√±a
    const user = await User.findByPk(id, {
      attributes: { exclude: ['Contrase√±a'] },
    });

    if (!user) {
      return res.status(404).json({ 
        error: 'Usuario no encontrado.' 
      });
    }

    // Obtener los roles del usuario
    const roles = await sequelize.query(`
      SELECT r.id, r.nombre, r.slug, r.descripcion, ru.asignado_en
      FROM roles r
      JOIN rolUsuarios ru ON r.id = ru.rol_id
      WHERE ru.usuario_id = :usuario_id
    `, {
      replacements: { usuario_id: id },
      type: sequelize.QueryTypes.SELECT,
    });

    res.status(200).json({
      message: 'Usuario obtenido exitosamente',
      user: {
        ...user.toJSON(),
        roles: roles.map(r => ({
          id: r.id,
          nombre: r.nombre,
          slug: r.slug,
          descripcion: r.descripcion,
          asignado_en: r.asignado_en
        })),
        roleSlugs: roles.map(r => r.slug),
      },
    });
  } catch (error) {
    res.status(500).json({ error: `Error al obtener usuario: ${error.message}` });
  }
};

export default { register, login, getProfile, verifyToken, changePassword, getAllUsers, deactivateUser, restoreUser, getUserById };
